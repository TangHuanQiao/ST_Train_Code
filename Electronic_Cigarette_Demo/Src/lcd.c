#include "lcd.h"
#include "lcdfont.h"
#include <stdlib.h>



#define Slave_Address 0x78      //OLED
#define OP_Command 0X00
#define OP_Data 0x40

#define Delay_ms( nTime ) HAL_Delay(nTime);

//GPIOA 10 for lcd reset.
#define RES_SET()       GPIOB-> BSRR |= 1<<4
#define RES_CLR()       GPIOB-> BRR  |= 1<<4


#define ACC_CONST 32

static char Display_orientation=0;
extern I2C_HandleTypeDef hi2c1;

void Write_Command(uint8_t  command)
{
	
	if(HAL_I2C_Mem_Write(&hi2c1,Slave_Address,OP_Command,I2C_MEMADD_SIZE_8BIT,&command,1, 0x10)!=HAL_OK)
	{
		

	}
}

void Write_Data(uint8_t  date)
{
	if(HAL_I2C_Mem_Write(&hi2c1,Slave_Address,OP_Data,I2C_MEMADD_SIZE_8BIT,&date,1, 0x10)!=HAL_OK)
	{
		
	}
}

void LCD_Set_Pos(unsigned char x, unsigned char y)
{

    if(Display_orientation==0)
    x = x+32;
    else
    x = x+0;
	Write_Command(0xb0+y);
	Write_Command(((x&0xf0)>>4)|0x10);
	Write_Command((x&0x0f)|0x01);
}

void Change_direction(void)
{
		if(Display_orientation!=0)
			Display_orientation = 0;
		else
			Display_orientation = 1;

		if(Display_orientation==0)
		{
        Write_Command(0xA0);       //Set Segment Re-map
        Write_Command(0xC0);       //Set COM Output Scan Direction
		}
		else
		{
        Write_Command(0xA1);       //Set Segment Re-map
        Write_Command(0xC8);       //Set COM Output Scan Direction
		}
}



void Init_LCD(void)
{
#if 0   //睿显熙LCD
        RES_SET();
        Delay_ms(45);
        RES_CLR();
        Delay_ms(45);
        RES_SET();
        Delay_ms(160);  //>=150ms.Wait for MTP-Read

        Write_Command(0x40);     //SCOLL LINE=0     ST7539    set duty
        Write_Command(0x85);     //SET PARTIAL SCREEN MODE
        Write_Command(0xf1);
        Write_Command(0x0F);     //SET COM END=32
        Write_Command(0xf2);
        Write_Command(0x00);     //SET PARTIAL START ADDRESS
        Write_Command(0xf3);
        Write_Command(0x0F);     //SET PARTIAL END ADDRESS
        Write_Command(0xa6);     //NORMAL DISPLAY
        Write_Command(0x89);     //SET RAM ADDRESS CONTROL
        Write_Command(0xa3);     //FRAME RATE=76Hz  a3
        Write_Command(0xe8);     //SET BIAS=1/6  e8
        Write_Command(0x81);
        Write_Command(0x84);     //SET VOP   BA=8.3V
        if(Display_orientation!=0)
        Write_Command(0xc4);
        else
        Write_Command(0xc2);		//设扫描放向
        Write_Command(0xa4);     //ALL pixel DISPLAY ON
        Write_Command(0xaf);     //DISPLAY ON
#endif
				
//int i;
			//	for(i= 0; i < 65536;i ++)
				{
					Delay_ms(10);
					RES_CLR();
					Delay_ms(50);
					RES_SET();
				}
				
				
        Delay_ms(100);

        Write_Command(0xAE);       //Display OFF (sleep mode)
        Write_Command(0xD5);       //Set Display Clock Divide Ratio/Oscillator Frequency
        Write_Command(0x52);       //320kHz //101hz     52
        Write_Command(0xA8);       //Set Multiplex Ratio
        Write_Command(0x0f);       //16
        Write_Command(0xD3);       //Set Display Offset
        Write_Command(0x00);       //
        Write_Command(0x40);       //Set Display Start Line
        Write_Command(0x8D);       //Set Display Offset
        Write_Command(0x14);       //VCC Generated by Internal DC/DC Circuit
		if(Display_orientation==0)
		{
        Write_Command(0xA0);       //Set Segment Re-map
        Write_Command(0xC0);       //Set COM Output Scan Direction
		}
		else
		{
        Write_Command(0xA1);       //Set Segment Re-map
        Write_Command(0xC8);       //Set COM Output Scan Direction
		}

        Write_Command(0xDA);       //Set COM Pins Hardware Configuration
        Write_Command(0x02);       //
        Write_Command(0x81);       //Set Contrast Control
        Write_Command(0xA0);     //0x30
        Write_Command(0xD9);       //Set Pre-charge Period
        Write_Command(0xf1);       //VCC Supplied Externally
        Write_Command(0xDB);       //Set VCOMH Deselect Level
        Write_Command(0x20);       //0x3C
        Write_Command(0xA4);       //Output follows RAM content
        Write_Command(0xA6);       //Set Normal Display
        Write_Command(0xAF);       //Set Display ON (normal mode)
}


void OLED_Display_On(void)
{
		Write_Command(0x8d);
		Write_Command(0x14);
		Write_Command(0xaf);
}

void OLED_Display_Off(void)
{
		Write_Command(0x8d);
		Write_Command(0x10);
		Write_Command(0xae);
}

void LCD_Clear(void)
{
	unsigned char i,n;
 	for(i=0;i<2;i++)
	{
            Write_Command(0xb0+i);
            Write_Command(0x00);
            Write_Command(0x12);
            for(n=0;n<128;n++)
            Write_Data(0x00);
	}
}


#if 0    //睿显熙LCD
void LCD_Clear(void)
{
	unsigned char i,n;
	for(i=0;i<2;i++)
	{
			Write_Command(0xb0+i);
		if(Display_orientation!=0)
		{
			Write_Command(0x10);
			Write_Command(0x00);
		}
		else
		{
		Write_Command(0x16);
		Write_Command(0x00);
		}
			for(n=0;n<96;n++)
		  	Write_Data(0x00);
	}
			//IC_IIC_Stop();
}
#endif
//void LCD_DrawPoint(uint8_t x,uint8_t y,uint8_t t)
//{
//	uint8_t pos,bx,temp=0;
//	if(x>96||y>16)return;
//	pos=7-y/8;
//	bx=y%8;
//	temp=1<<(7-bx);
//	if(t)LCD_GRAM[x][pos]|=temp;
//	else LCD_GRAM[x][pos]&=~temp;
//}


void Disp_Batter_Bmp(unsigned char x, unsigned char ch)
{
    unsigned int adder;
    unsigned char i,j;
    adder = ch*20;
    if(x>96)return;
    for(j=0;j<4;j++)
    {
        LCD_Set_Pos(x,j);
		for(i=0;i<10;i++)
		{
        Write_Data(Batter_bmp[adder]);
        adder++;
		}
    }
}


//X显示数据X位置CCH ->图形  ch = 0-6
void Disp_Batter_Bmp2(unsigned char x,unsigned char ch)
{
		unsigned int adder;
		unsigned char i;
		adder = ch * 96;
			LCD_Set_Pos(x,0);
			for(i=0;i<24;i++)
			{
			Write_Data(battery_bmp2[adder]);
			adder++;
			}
			LCD_Set_Pos(x,1);
			for(i=0;i<24;i++)
			{
			Write_Data(battery_bmp2[adder]);
			adder++;
			}
			LCD_Set_Pos(x,2);
			for(i=0;i<24;i++)
			{
			Write_Data(battery_bmp2[adder]);
			adder++;
			}
			LCD_Set_Pos(x,3);
			for(i=0;i<24;i++)
			{
			Write_Data(battery_bmp2[adder]);
			adder++;
			}
}
//==============================================================
//函数名：LCD_P6x8Str(unsigned char x,unsigned char y,unsigned char *p)
//功能描述：写入一组标准ASCII字符串
//参数：显示的位置（x,y），y为页范围0～7，要显示的字符串
//返回：无
//==============================================================
void LCD_P6x8Str(unsigned char x,unsigned char y,unsigned char ch[])
{
  unsigned char c=0,i=0,j=0;
  while (ch[j]!='\0')
  {
    c =ch[j]-ACC_CONST;
    if(x>128){x=0;y++;}
    LCD_Set_Pos(x,y);
  	for(i=0;i<6;i++)
		{
		Write_Data(F6x8[c][i]);
		}
  	x+=6;
  	j++;
  }
}
//==============================================================
//函数名：LCD_P8x16Str(unsigned char x,unsigned char y,unsigned char *p)
//功能描述：写入一组标准ASCII字符串
//参数：显示的位置（x,y），y为页范围0～7，要显示的字符串
//返回：无
//==============================================================
void LCD_P8x16Str(unsigned char x,unsigned char y,unsigned char ch[])
{
  unsigned char c=0,i=0,j=0;
  while (ch[j]!='\0')
  {
    c =ch[j]- ACC_CONST;
    if(x>128){x=0;y++;}
    LCD_Set_Pos(x,y);
  	for(i=0;i<8;i++)
		{
		Write_Data(F8X16[c*16+i]);
		}
		
  	LCD_Set_Pos(x,y+1);
  	for(i=0;i<8;i++)
		{
		Write_Data(F8X16[c*16+i+8]);
		}
  	x+=8;
  	j++;
  }
}

//在指定位置显示一个字符,包括部分字符
//x:0~127
//y:0~63
//mode:0,反白显示;1,正常显示
//size:选择字体 16/12

#define Max_Column	96
#define Max_Row		16
void OLED_ShowChar(unsigned char x,unsigned char y,unsigned char size,unsigned char chr)
{
	unsigned char c=0,i=0;
		c=chr-' ';//得到偏移后的值
		if(x>Max_Column-1){x=0;y=y+2;}
		if(size !=0)
			{
                LCD_Set_Pos(x,y);
                for(i=0;i<8;i++)
                Write_Data(F8X16[c*16+i]);
                LCD_Set_Pos(x,y+1);
                for(i=0;i<8;i++)
                Write_Data(F8X16[c*16+i+8]);
			}
			else
            {
				LCD_Set_Pos(x,y);
				for(i=0;i<6;i++)
				Write_Data(F6x8[c][i]);
			}
}

void LCD_P16x16Str(unsigned char x,unsigned char y,unsigned char ch[])
{
  unsigned char c=0,i=0,j=0;

  while (ch[j]!='\0')
  {
    c =ch[j]-ACC_CONST;
    if(x>120){x=0;y++;}
    LCD_Set_Pos(x,y);
  	for(i=0;i<16;i++)
		{
  	    Write_Data(F16X16[c*32+i]);

		}
  	LCD_Set_Pos(x,y+1);
  	for(i=0;i<16;i++)
		{
  	   Write_Data(F16X16[c*32+i+16]);
		}
  	x+=16;
  	j++;
  }
}

void LCD_P6x8StrD(unsigned char x,unsigned char y,unsigned char ch[]);

const unsigned char tmd[10] = {'0','1','2','3','4','5','6','7','8','9'};
//----------------------------------------------显示数字 三位数字
// x,y 起始坐标 SIZE 字体大小 0=6X8 非0 8x6
void Disp_Num(unsigned char x,unsigned char y,unsigned char size, unsigned int num)
{
#if 0
        unsigned char temp[3];
        unsigned char w;

        temp[2] = num / 100;
        temp[1] = num / 10 % 10;
        temp[0] = num % 10;
        if(size==0)
        w = 6;
        else w = 8;
        OLED_ShowChar(x,y,size,tmd[temp[2]]);
        OLED_ShowChar(x+w,y,size,tmd[temp[1]]);
        OLED_ShowChar(x+w+w,y,size,tmd[temp[0]]);
#endif
//--------------------------------动态内存内配---------------------------------
		unsigned char w;
		unsigned char *Pm_Buff = (unsigned char *)malloc(3 *sizeof(unsigned char));
		if(Pm_Buff==NULL)
		{
		return;
		}
		*(Pm_Buff+0) = num / 100;
		*(Pm_Buff+1) = num /10 % 10;
		*(Pm_Buff+2) = num % 10;
		if(size==0)
		w = 6;
		else w = 8;
		
		//OLED_ShowChar(x+w,y,size,'.');		
		
		OLED_ShowChar(x,y,size,tmd[*(Pm_Buff+0)]);
		
		
		LCD_P6x8StrD(x+w,y,".");
		
		
		OLED_ShowChar(x+w+w-1,y,size,tmd[*(Pm_Buff+1)]);	

		OLED_ShowChar(x+w+w+w-1,y,size,tmd[*(Pm_Buff+2)]);
		free(Pm_Buff);
}

void Disp_RNum(unsigned char x,unsigned char y,unsigned char size, unsigned int num)
{
#if 0
        unsigned char temp[3];
        unsigned char w;

        temp[2] = num / 100;
        temp[1] = num / 10 % 10;
        temp[0] = num % 10;
        if(size==0)
        w = 6;
        else w = 8;
        OLED_ShowChar(x,y,size,tmd[temp[2]]);
        OLED_ShowChar(x+w,y,size,tmd[temp[1]]);
        OLED_ShowChar(x+w+w,y,size,tmd[temp[0]]);
#endif
//--------------------------------动态内存内配---------------------------------
		unsigned char w;
		unsigned char *Pm_Buff = (unsigned char *)malloc(3 *sizeof(unsigned char));
		if(Pm_Buff==NULL)
		{
		return;
		}
		*(Pm_Buff+0) = num / 10;
		*(Pm_Buff+1) = num  % 10;
		//*(Pm_Buff+2) = num % 10;
		if(size==0)
		w = 6;
		else w = 8;
		
		//OLED_ShowChar(x+w,y,size,'.');		
		
		LCD_P6x8StrD(x+w,y,".");
		
		OLED_ShowChar(x,y,size,tmd[*(Pm_Buff+0)]);
		OLED_ShowChar(x+w+w-1,y,size,tmd[*(Pm_Buff+1)]);	
		OLED_ShowChar(x+w+w+w-1,y,size,tmd[*(Pm_Buff+1)]);	
		//		OLED_ShowChar(x+w+w+w-1,y,size,tmd[*(Pm_Buff+2)]);
		free(Pm_Buff);
}


void Disp_WNum(unsigned char x,unsigned char y,unsigned char size, unsigned int num)
{

//--------------------------------动态内存内配---------------------------------
		unsigned char w,temp;
		unsigned char *Pm_Buff = (unsigned char *)malloc(3 *sizeof(unsigned char));
		if(Pm_Buff==NULL)
		{
				return;
		}
		
		temp = num/100;
		
//		printf("temp =%d",temp);
		*(Pm_Buff+0) = temp;
		
		*(Pm_Buff+1) = num/10 % 10;
		*(Pm_Buff+2) = num % 10;
				
		if(size==0)
		w = 6;
		else w = 8;

		OLED_ShowChar(x+w+w,y,size,'.');	
		
		if(temp > 0)
		OLED_ShowChar(x,y,size,tmd[*(Pm_Buff+0)]);
		else
		{
			LCD_P8x16Str(x,0," ");		//clear 
		}
		
		OLED_ShowChar(x+w,y,size,tmd[*(Pm_Buff+1)]);	
		OLED_ShowChar(x+w+w+w,y,size,tmd[*(Pm_Buff+2)]);
		free(Pm_Buff);
}
 const unsigned char F6x82[][4] =
{
		 0x00, 0x60, 0x60, 0x00,// .
};

void LCD_P6x8StrD(unsigned char x,unsigned char y,unsigned char ch[])
{
  unsigned char i=0,j=0;
  while (ch[j]!='\0')
  {
//    c =ch[j]-ACC_CONST;
    if(x>128){x=0;y++;}
    LCD_Set_Pos(x,y);
  	for(i=0;i<4;i++)
		{
		Write_Data(F6x82[0][i]);
		}
  	x+=6;
  	j++;
  }
}
